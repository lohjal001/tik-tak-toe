import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

public class GUI  {
    /*Upon drawing active coordinates we complete a round so we can use that method to update a counter for roundNmbr
    This means we can figure out whether to place an X or O (roundNmbr % 2 -> means O must be at index 0 ; check if first round) from a final char array and not need Playingfield to
    handle that for the GUI -> Better logical structure, GUI paints the values generated by the PlayingField and
    the players actions thereupon

     */
    private int roundNmbr;
    /*Values reflected in name, O at index 0 and x at index 1*/
    private final char[] xAndO = {'X','O'};
    private final JFrame framePlayingField;
    private final JPanel panelOuterPlayingField;
    private final JPanel panelInnerPlayingField;
    private final JLabel labelOuterPlayingFieldNorth;
    private final JLabel labelOuterPlayingFieldSouth;
    private final JButton[][] buttonArray = new JButton[3][3];
    private JButton b = new JButton();
    /*An action-listener array we can send to the playing-field to trigger on action-performed on GUI*/

    private boolean is1PlayerMode;
    /*Let´s us use the inputs from the player(s)*/
    private String[] playerNames = new String[2];
    private ImageIcon optionIcon;
    public GUI() {

        roundNmbr = 1;
        framePlayingField = new JFrame("TicTacToe");
        framePlayingField.setSize(600, 600);
        framePlayingField.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);

        panelOuterPlayingField = new JPanel();
        framePlayingField.add(panelOuterPlayingField);
        panelOuterPlayingField.setLayout(new BorderLayout());

        labelOuterPlayingFieldNorth = new JLabel("Player One and Player Two");
        panelOuterPlayingField.add(labelOuterPlayingFieldNorth, BorderLayout.NORTH);

        labelOuterPlayingFieldSouth = new JLabel("Score and Wins");
        panelOuterPlayingField.add(labelOuterPlayingFieldSouth, BorderLayout.SOUTH);

        panelInnerPlayingField = new JPanel();
        panelOuterPlayingField.add(panelInnerPlayingField, BorderLayout.CENTER);
        panelInnerPlayingField.setLayout(new GridLayout(3, 3));

        JPanel inputPanel = new JPanel();

        //initialize the buttonArray into our game board
        for (int i = 0; i < 3; i++) {
            for (int k = 0; k < 3; k++) {
                buttonArray[i][k] = new JButton();
                panelInnerPlayingField.add(buttonArray[i][k]);
            }
        }
         optionIcon = new ImageIcon("529185.png");
        String[] selectionTexts = {"1 Spelare", "2 spelare"};
//        JOptionPane singleOrMultiplayerPane = new JOptionPane(selectionTexts,JOptionPane.QUESTION_MESSAGE,JOptionPane.YES_NO_OPTION,optionIcon);
//        singleOrMultiplayerPane.setSize(200,200);
//        panelOuterPlayingField.add(singleOrMultiplayerPane);


        framePlayingField.setVisible(true);
        String[] options = {"1 Spelare", "2 Spelare"};
        String n = (String) JOptionPane.showInputDialog(null, "Vänligen välj antal spelare",
                "Tic-tac-toe", JOptionPane.QUESTION_MESSAGE, optionIcon, options, options[1]);
        is1PlayerMode = n.equals(options[0]);
        if (is1PlayerMode) {

            playerNames[0] = JOptionPane.showInputDialog(null, "Vänligen ange spelarnamn:", "Tic-tac-toe", JOptionPane.QUESTION_MESSAGE);
            playerNames[1] = "Dator-spelare";

        }
        else{
            playerNames[0] = JOptionPane.showInputDialog(null, "Vänligen ange spelarnamn:", "Spelare 1", JOptionPane.QUESTION_MESSAGE);
            playerNames[1] = JOptionPane.showInputDialog(null, "Vänligen ange spelarnamn:", "Spelare 2", JOptionPane.QUESTION_MESSAGE);


        }
        labelOuterPlayingFieldNorth.setText(playerNames[0]+" | vs | "+playerNames[1]);
        labelOuterPlayingFieldSouth.setText(playerNames[0]+" W : L\n "+playerNames[1]+" W : L");



    }

    /**This method adds the specified ActionListener to the buttons
     *
     * @param buttonListener
     */
    public void setActionListener(ActionListener buttonListener){
        for(int i = 0 ; i < 3 ; i++) for(int k = 0; k < 3; k++){
            /*Adds the external listeners to the buttonArray*/
            buttonArray[i][k].addActionListener(buttonListener);

        }

        }


    /**
     * This updates the GUI according to the latest move
     *
     * @param playerArray
     */
    public void drawActiveCoordinates(Player[] playerArray) {
        /*Since this means a move has been made once it is called we can use this for roundcounting inside the GUI*/
        roundNmbr++;
        for (int playerIndex = 0; playerIndex < 2; playerIndex++) {
            for (int row = 0; row < 3; row++) {
                for (int col = 0; col < 3; col++) {
                    if (playerArray[playerIndex].getActiveCoordinates()[col][row] == 1) {
                        buttonArray[col][row].setText(String.valueOf(playerArray[playerIndex].getMark()));
                    }


                }
            }
        }
            framePlayingField.invalidate();
            framePlayingField.validate();
            framePlayingField.repaint();


        }

    /**Takes a button and returns the coordinates where it is placed
     *
     *
     * @param b
     * @return int[] returnArray = {x-coordinate,y-coordinate} ; origin at top left
     */
    public int[] getCoordinatesOfClickedButton(JButton b) {
        int[] returnArray = new int[2];
        /*Alrik-implemented for-loop structure, fair enough, upon refactoring I get the appeal*/
        for (int i = 0; i < 3; i++)
            for (int k = 0; k < 3; k++) {
                if (buttonArray[i][k] == b) {
                    returnArray[0] = i;
                    returnArray[1] = k;


                    return returnArray;
                }
            }
        return returnArray;
    }
    public JButton getB(){

        return b;

    }

    /**
     * This method returns the result of the player-mode-selection
     *
     * @return true if singleplayer-mode is selected, false otherwise
     */
    public boolean is1PlayerMode() {
        return is1PlayerMode;
    }



    /**
     * Returns an array with the player-names from the user-input at the start of running
     *
     * @return playerNamesIn
     */
    public String[] getPlayerNames() {
        return playerNames;
    }



    public JButton[][] getButtonArray() {
        return buttonArray;
    }

    /**This method checks the player activeCoordinates
     * for their last move and determines if that was a winning one.
     * If so it announces a win for that player and then asks if they want to play again. If so true is returned
     * @param latestActivePlayer
     * @param lastMoveCoordinates
     * @return wantsToPlayAgain
     */
    public boolean announceIfWin(Player latestActivePlayer, int[] lastMoveCoordinates){
        boolean win = false;

        int[][] activeCoordinates = latestActivePlayer.getActiveCoordinates();

        /*If any of them returns true win will be set to true*/

        win = ((checkRow(latestActivePlayer, lastMoveCoordinates) || (checkColumn(latestActivePlayer, lastMoveCoordinates)) || (checkDiagonal(latestActivePlayer, lastMoveCoordinates))));
        if(win) latestActivePlayer.addLossOrWin(true);
        if(win) {
            String[] message = {latestActivePlayer.name + " vann på runda : " + roundNmbr};
            String[] option = {"Vidare"};
            JOptionPane.showOptionDialog(null, message, "Gratulerar!", JOptionPane.CLOSED_OPTION, JOptionPane.INFORMATION_MESSAGE, optionIcon, option, option);
            String[] options = {"Spela igen", "Avsluta"};
            String n = (String) JOptionPane.showInputDialog(null, "Önskar ni att spela igen?",
                    "Tic-tac-toe", JOptionPane.QUESTION_MESSAGE, optionIcon, options, options[1]);
           boolean playAgain = n.equals(options[0]);
           if(playAgain) {
               Main.gameIsOver = true;

               return true;
           }
           else {
               Main.gameIsOver = true;
               Main.seriesOfGamesIsOver = true;
            }

        }
        return false;
    }

    /**Checks the last move and sees if it led to a win, if so it returns
     * true, otherwise false
     *
     * @return ifWin
     */
      private static boolean checkRow(Player lastActivePlayer, int[] lastMoveCoordinates){
          /*Before we check for a win the win-token is set to false*/
          boolean win = false;
          int[][] activeCoordinates = lastActivePlayer.getActiveCoordinates();
          /*Since we make a move there*/
          int numberInRow = 1;
          /*Here we start the at the column of the last move and check the row of that column, if it is filled*/
          for(int i = lastMoveCoordinates[1]+1; i < lastMoveCoordinates[1] +3 ; i++){
              if(activeCoordinates[lastMoveCoordinates[0]][i % activeCoordinates.length] == 1) numberInRow++;
              /*Once we reach three in a row we set win to true */
              if(numberInRow == 3) win = true;

          }
          return win;

      }

    /**Returns true if the column is filled with the players marks
     *
     * @param lastActivePlayer
     * @param lastMoveCoordinates
     * @return win
     */
      private static boolean checkColumn(Player lastActivePlayer, int[] lastMoveCoordinates){
          /*Before we check for a win the win-token is set to false*/
          boolean win = false;
          int[][] activeCoordinates = lastActivePlayer.getActiveCoordinates();
          /*Since we make a move there*/
          int numberInRow = 1;
          /*Here we start the at the column of the last move and check the row of that column, if it is filled*/
          for(int i = lastMoveCoordinates[0]+1; i < lastMoveCoordinates[0] +3 ; i++){
              if(activeCoordinates[i% activeCoordinates.length][lastMoveCoordinates[1]] == 1) numberInRow++;
              /*Once we reach three in a row we set win to true */
              if(numberInRow == 3) win = true;

          }
          return win;


      }

    /**Returns true if the diagonal is occupied with the player´s marks
     *
     *
     * @param lastActivePlayer
     * @param lastMoveCoordinates
     * @return ifWin
     */
      private static boolean checkDiagonal(Player lastActivePlayer, int[] lastMoveCoordinates) {
          /*Before we check for a win the win-token is set to false*/
          boolean win = false;
          int[][] activeCoordinates = lastActivePlayer.getActiveCoordinates();
          /*Since we make a move there*/
          int numberInRow = 1;
          /*We only need to check the diagonals if the centerpiece is occupied, otherwise it will never win*/
          if ((lastMoveCoordinates[0] == 1 && lastMoveCoordinates[1] == 1) || (activeCoordinates[1][1] == 1)) {
              /*Since we know the centerpiece is occupied we just need to pair-wise check the left and right diagonal*/
              if(activeCoordinates[0][0] == 1 && activeCoordinates[2][2] == 1) return win = true;
              else if(activeCoordinates[2][0] == 1 && activeCoordinates[0][2] == 1) return win = true;



          }
          return false;
      }
    }






